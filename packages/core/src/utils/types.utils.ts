import util from "util";

const ToString = Function.prototype.toString;
const hasOwn = Object.prototype.hasOwnProperty;
const toStr = Object.prototype.toString;

/**
 * 判断是否时纯对象
 * @param obj
 */
export const isPlainObject =  (obj) =>{
  if (!obj || toStr.call(obj) !== '[object Object]') {
    return false;
  }

  const hasOwnConstructor = hasOwn.call(obj, 'constructor');
  const hasIsPrototypeOf =
    obj.constructor &&
    obj.constructor.prototype &&
    hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  // Not own constructor property must be Object
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  let key;
  for (key in obj) {
    /**/
  }

  return typeof key === 'undefined' || hasOwn.call(obj, key);
}

/**
 * 是否是正则
 * @param value
 */
export function isRegExp(value) {
  return util.types.isRegExp(value);
}

/**
 * 判断指定对象是否时类
 * @param obj 指定对象
 * @param strict
 * @constructor
 */
export const isClass = (obj: any,strict?:any) => {
  if (typeof obj != "function") return false;
  const str = obj.toString();
  // async function or arrow function
  if (obj.prototype === undefined) return false;
  // generator function or malformed definition
  if (obj.prototype.constructor !== obj) return false;
  // ES6 class
  if (str.slice(0, 5) == "class") return true;
  // has own prototype properties
  if (Object.getOwnPropertyNames(obj.prototype).length >= 2) return true;
  // anonymous function
  if (/^function\s+\(|^function\s+anonymous\(/.test(str)) return false;
  // ES5 class without `this` in the body and the name's first character
  // upper-cased.
  if (strict && /^function\s+[A-Z]/.test(str)) return true;
  // has `this` in the body
  if (/\b\(this\b|\bthis[\.\[]\b/.test(str)) {
    // not strict or ES5 class generated by babel
    if (!strict || /classCallCheck\(this/.test(str)) return true;

    return /^function\sdefault_\d+\s*\(/.test(str);
  }
  return false;
}

/**
 * 判断是否是方法
 * @param value
 */
export function isFunction(value) {
  return typeof value === 'function';
}

/**
 * 是否时异步方法
 * @param value
 */
export function isAsyncFunction(value) {
  return util.types.isAsyncFunction(value);
}

/**
 * 判断是否时create工厂
 * @param value
 */
export function isGeneratorFunction(value) {
  return util.types.isGeneratorFunction(value);
}

/**
 * 判断是否是异步函数
 * @param value
 */
export function isPromise(value) {
  return util.types.isPromise(value);
}



/**
 * 获取指定对象的内容
 * @param fn
 */
function fnBody(fn) {
  return ToString.call(fn)
    .replace(/^[^{]*{\s*/, '')
    .replace(/\s*}[^}]*$/, '');
}

/**
 * 类型相关内容
 */
export const Types = {
  isClass,
  isRegExp,
  isPromise,
  isFunction,
  isPlainObject,
  isAsyncFunction,
  isGeneratorFunction
}